
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>system &#8212; Vibration Testing 0.22 documentation</title>
    <link rel="stylesheet" href="../_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '0.22',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true,
        SOURCELINK_SUFFIX: '.txt'
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
   
  <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head>
  <body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for system</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">System manipulation, reduction, and corrections functions.</span>

<span class="sd">@author: Joseph C. Slater</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="n">__license__</span> <span class="o">=</span> <span class="s2">&quot;Joseph C. Slater&quot;</span>

<span class="n">__docformat__</span> <span class="o">=</span> <span class="s1">&#39;reStructuredText&#39;</span>


<span class="kn">import</span> <span class="nn">math</span>
<span class="c1"># import warnings</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="c1"># import control as ctrl</span>
<span class="kn">import</span> <span class="nn">scipy.signal</span> <span class="k">as</span> <span class="nn">sig</span>
<span class="kn">import</span> <span class="nn">scipy.linalg</span> <span class="k">as</span> <span class="nn">la</span>
<span class="c1"># np.set_printoptions(precision=4, suppress=True)</span>


<div class="viewcode-block" id="d2c"><a class="viewcode-back" href="../reference/system.html#system.d2c">[docs]</a><span class="k">def</span> <span class="nf">d2c</span><span class="p">(</span><span class="n">Ad</span><span class="p">,</span> <span class="n">Bd</span><span class="p">,</span> <span class="n">C</span><span class="p">,</span> <span class="n">D</span><span class="p">,</span> <span class="n">dt</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Return continuous A, B, C, D from discrete form.</span>

<span class="sd">    Converts a set of digital state space system matrices to their</span>
<span class="sd">    continuous counterpart.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    Ad, Bd, C, D : float arrays</span>
<span class="sd">        Discrete state space system matrices</span>
<span class="sd">    dt  : float</span>
<span class="sd">        Time step of discrete system</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    A, B, C, D : float arrays</span>
<span class="sd">        State space system matrices</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; import vibrationtesting as vt</span>
<span class="sd">    &gt;&gt;&gt; Ad = np.array([[ 0.9999,0.0001,0.01,0.],</span>
<span class="sd">    ...                [ 0.,0.9999,0.,0.01],</span>
<span class="sd">    ...                [-0.014,0.012,0.9999,0.0001],</span>
<span class="sd">    ...                [ 0.008, -0.014,0.0001,0.9999]])</span>
<span class="sd">    &gt;&gt;&gt; Bd = np.array([[ 0.  ],</span>
<span class="sd">    ...                [ 0.  ],</span>
<span class="sd">    ...                [ 0.  ],</span>
<span class="sd">    ...                [ 0.01]])</span>
<span class="sd">    &gt;&gt;&gt; C = np.array([[-1.4, 1.2, -0.0058, 0.0014]])</span>
<span class="sd">    &gt;&gt;&gt; D = np.array([[-0.2]])</span>
<span class="sd">    &gt;&gt;&gt; A, B, *_ = vt.d2c(Ad, Bd, C, D, 0.01)</span>
<span class="sd">    &gt;&gt;&gt; print(A)</span>
<span class="sd">    [[-0.003   0.004   1.0001 -0.0001]</span>
<span class="sd">     [-0.004  -0.003  -0.      1.0001]</span>
<span class="sd">     [-1.4001  1.2001 -0.003   0.004 ]</span>
<span class="sd">     [ 0.8001 -1.4001  0.006  -0.003 ]]</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    .. note:: Zero-order hold solution</span>
<span class="sd">    .. note:: discrepancies between :func:`c2d` and :func:`d2c` are due to \</span>
<span class="sd">      typing truncation errors.</span>
<span class="sd">    .. seealso:: :func:`c2d`.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Old school (very old)</span>
    <span class="c1"># A = la.logm(Ad) / dt</span>
    <span class="c1"># B = la.solve((Ad - np.eye(A.shape[0])), A) @ Bd</span>
    <span class="n">sa</span> <span class="o">=</span> <span class="n">Ad</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">sb</span> <span class="o">=</span> <span class="n">Bd</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">AAd</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">Ad</span><span class="p">,</span>                  <span class="n">Bd</span><span class="p">)),</span>
                     <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">sb</span><span class="p">,</span> <span class="n">sa</span><span class="p">)),</span>  <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="n">sb</span><span class="p">)))))</span>
    <span class="n">AA</span> <span class="o">=</span> <span class="n">la</span><span class="o">.</span><span class="n">logm</span><span class="p">(</span><span class="n">AAd</span><span class="p">)</span> <span class="o">/</span> <span class="n">dt</span>
    <span class="n">A</span> <span class="o">=</span> <span class="n">AA</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">sa</span><span class="p">,</span> <span class="mi">0</span><span class="p">:</span><span class="n">sa</span><span class="p">]</span>
    <span class="n">B</span> <span class="o">=</span> <span class="n">AA</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">sa</span><span class="p">,</span> <span class="n">sa</span><span class="p">:]</span>
    <span class="k">return</span> <span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">C</span><span class="p">,</span> <span class="n">D</span></div>


<div class="viewcode-block" id="c2d"><a class="viewcode-back" href="../reference/system.html#system.c2d">[docs]</a><span class="k">def</span> <span class="nf">c2d</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">C</span><span class="p">,</span> <span class="n">D</span><span class="p">,</span> <span class="n">dt</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Convert continuous state system to discrete time.</span>

<span class="sd">    Converts a set of continuous state space system matrices to their</span>
<span class="sd">    discrete counterpart.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    A, B, C, D : float arrays</span>
<span class="sd">        State space system matrices</span>
<span class="sd">    dt : float</span>
<span class="sd">        Time step of discrete system</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    Ad, Bd, C, D : float arrays</span>
<span class="sd">        Discrete state space system matrices</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; import numpy as np</span>
<span class="sd">    &gt;&gt;&gt; np.set_printoptions(precision=4, suppress=True)</span>
<span class="sd">    &gt;&gt;&gt; import vibrationtesting as vt</span>
<span class="sd">    &gt;&gt;&gt; A1 = np.array([[ 0.,   0. ,  1.    ,  0.    ]])</span>
<span class="sd">    &gt;&gt;&gt; A2 = np.array([[ 0.,   0. ,  0.    ,  1.    ]])</span>
<span class="sd">    &gt;&gt;&gt; A3 = np.array([[-1.4,  1.2, -0.0058,  0.0014]])</span>
<span class="sd">    &gt;&gt;&gt; A4 = np.array([[ 0.8, -1.4,  0.0016, -0.0038]])</span>
<span class="sd">    &gt;&gt;&gt; A = np.array([[ 0.,   0. ,  1.    ,  0.    ],</span>
<span class="sd">    ...               [ 0.,   0. ,  0.    ,  1.    ],</span>
<span class="sd">    ...               [-1.4,  1.2, -0.0058,  0.0014],</span>
<span class="sd">    ...               [ 0.8, -1.4,  0.0016, -0.0038]])</span>
<span class="sd">    &gt;&gt;&gt; B = np.array([[ 0.],</span>
<span class="sd">    ...               [ 0.],</span>
<span class="sd">    ...               [ 0.],</span>
<span class="sd">    ...               [ 1.]])</span>
<span class="sd">    &gt;&gt;&gt; C = np.array([[-1.4, 1.2, -0.0058, 0.0014]])</span>
<span class="sd">    &gt;&gt;&gt; D = np.array([[-0.2]])</span>
<span class="sd">    &gt;&gt;&gt; Ad, Bd, *_ = vt.c2d(A, B, C, D, 0.01)</span>
<span class="sd">    &gt;&gt;&gt; print(Ad)</span>
<span class="sd">    [[ 0.9999  0.0001  0.01    0.    ]</span>
<span class="sd">     [ 0.      0.9999  0.      0.01  ]</span>
<span class="sd">     [-0.014   0.012   0.9999  0.0001]</span>
<span class="sd">     [ 0.008  -0.014   0.0001  0.9999]]</span>
<span class="sd">    &gt;&gt;&gt; print(Bd)</span>
<span class="sd">    [[ 0.  ]</span>
<span class="sd">     [ 0.  ]</span>
<span class="sd">     [ 0.  ]</span>
<span class="sd">     [ 0.01]]</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    .. note:: Zero-order hold solution</span>
<span class="sd">    .. seealso:: :func:`d2c`.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">Ad</span><span class="p">,</span> <span class="n">Bd</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">sig</span><span class="o">.</span><span class="n">cont2discrete</span><span class="p">((</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">C</span><span class="p">,</span> <span class="n">D</span><span class="p">),</span> <span class="n">dt</span><span class="p">)</span>
    <span class="c1"># Ad = la.expm(A * dt)</span>
    <span class="c1"># Bd = la.solve(A, (Ad - np.eye(A.shape[0]))) @ B</span>
    <span class="k">return</span> <span class="n">Ad</span><span class="p">,</span> <span class="n">Bd</span><span class="p">,</span> <span class="n">C</span><span class="p">,</span> <span class="n">D</span></div>


<div class="viewcode-block" id="ssfrf"><a class="viewcode-back" href="../reference/system.html#system.ssfrf">[docs]</a><span class="k">def</span> <span class="nf">ssfrf</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">C</span><span class="p">,</span> <span class="n">D</span><span class="p">,</span> <span class="n">omega_low</span><span class="p">,</span> <span class="n">omega_high</span><span class="p">,</span> <span class="n">in_index</span><span class="p">,</span> <span class="n">out_index</span><span class="p">,</span>
          <span class="n">num_freqs</span><span class="o">=</span><span class="mi">1000</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Return FRF of state space system.</span>

<span class="sd">    Obtains the computed FRF of a state space system between selected input</span>
<span class="sd">    and output over frequency range of interest.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    A, B, C, D : float arrays</span>
<span class="sd">                 state system matrices</span>
<span class="sd">    omega_low, omega_high : floats</span>
<span class="sd">                 low and high frequencies for evaluation</span>
<span class="sd">    in_index, out_index : ints</span>
<span class="sd">                input and output numbers (starting at 1)</span>
<span class="sd">    num_freqs : int</span>
<span class="sd">                number of frequencies at which to return FRF</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    omega : float array</span>
<span class="sd">            frequency vector</span>
<span class="sd">    H : float array</span>
<span class="sd">        frequency response function</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; import vibrationtesting as vt</span>
<span class="sd">    &gt;&gt;&gt; A = np.array([[ 0.,   0. ,  1.    ,  0.    ],</span>
<span class="sd">    ...               [ 0.,   0. ,  0.    ,  1.    ],</span>
<span class="sd">    ...               [-1.4,  1.2, -0.0058,  0.0014],</span>
<span class="sd">    ...               [ 0.8, -1.4,  0.0016, -0.0038]])</span>
<span class="sd">    &gt;&gt;&gt; B = np.array([[ 0.],</span>
<span class="sd">    ...               [ 0.],</span>
<span class="sd">    ...               [ 0.],</span>
<span class="sd">    ...               [ 1.]])</span>
<span class="sd">    &gt;&gt;&gt; C = np.array([[-1.4, 1.2, -0.0058, 0.0014]])</span>
<span class="sd">    &gt;&gt;&gt; D = np.array([[-0.2]])</span>
<span class="sd">    &gt;&gt;&gt; omega, H = vt.ssfrf(A, B, C, D, 0, 3.5, 1, 1)</span>
<span class="sd">    &gt;&gt;&gt; vt.frfplot(omega, H) # doctest: +SKIP</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># A, B, C, D = ctrl.ssdata(sys)</span>
    <span class="k">if</span> <span class="mi">0</span> <span class="o">&lt;</span> <span class="n">in_index</span> <span class="o">&lt;</span> <span class="p">(</span><span class="n">B</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="ow">and</span> <span class="mi">0</span> <span class="o">&lt;</span> <span class="n">out_index</span> <span class="o">&lt;</span> <span class="p">(</span><span class="n">C</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
        <span class="n">sa</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">omega</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">omega_low</span><span class="p">,</span> <span class="n">omega_high</span><span class="p">,</span> <span class="n">num_freqs</span><span class="p">)</span>
        <span class="n">H</span> <span class="o">=</span> <span class="n">omega</span> <span class="o">*</span> <span class="mi">1</span><span class="n">j</span>
        <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">w</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">omega</span><span class="p">):</span>
<div class="viewcode-block" id="sos_frf"><a class="viewcode-back" href="../reference/system.html#system.sos_frf">[docs]</a>            <span class="n">H</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">C</span><span class="nd">@la</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">w</span> <span class="o">*</span> <span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="n">sa</span><span class="p">)</span> <span class="o">-</span> <span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">)</span> <span class="o">+</span> <span class="n">D</span><span class="p">)[</span><span class="n">out_index</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span>
                                                                <span class="n">in_index</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="s1">&#39;Input </span><span class="si">{}</span><span class="s1"> or output </span><span class="si">{}</span><span class="s1"> infeasible.&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">in_index</span><span class="p">,</span> <span class="n">out_index</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">omega</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="n">H</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span></div>


<span class="k">def</span> <span class="nf">sos_frf</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="n">C</span><span class="p">,</span> <span class="n">K</span><span class="p">,</span> <span class="n">Bt</span><span class="p">,</span> <span class="n">Cd</span><span class="p">,</span> <span class="n">Cv</span><span class="p">,</span> <span class="n">Ca</span><span class="p">,</span> <span class="n">omega_low</span><span class="p">,</span> <span class="n">omega_high</span><span class="p">,</span>
            <span class="n">in_index</span><span class="p">,</span> <span class="n">out_index</span><span class="p">,</span> <span class="n">num_freqs</span><span class="o">=</span><span class="mi">1000</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Return FRF of second order system.</span>

<span class="sd">    Given second order linear matrix equation of the form</span>
<span class="sd">    :math:`M\\ddot{x} + C \\dot{x} + K x= \\tilde{B} u`</span>
<span class="sd">    and</span>
<span class="sd">    :math:`y = C_d x + C_v \\dot{x} + C_a\\ddot{x}`</span>
<span class="sd">    converts to state space form and returns the requested frequency response</span>
<span class="sd">    function</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    M, C, K, Bt, Cd, Cv, Cd : float arrays</span>
<span class="sd">        Mass, damping, stiffness, input, displacement sensor, velocimeter,</span>
<span class="sd">        and accelerometer matrices</span>
<span class="sd">    omega_low, omega_high : floats</span>
<span class="sd">        low and high frequencies for evaluation</span>
<span class="sd">    in_index, out_index : ints</span>
<span class="sd">        input and output numbers (starting at 1)</span>
<span class="sd">    num_freqs : int</span>
<span class="sd">        number of frequencies at which to return FRF</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    omega : float array</span>
<span class="sd">        frequency vector</span>
<span class="sd">    H : float array</span>
<span class="sd">        frequency response function</span>

<span class="sd">    Examples not working for second order system</span>

<span class="sd">    Need to make one for second order expansion</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; import vibrationtesting as vt</span>
<span class="sd">    &gt;&gt;&gt; A = np.array([[ 0.,   0. ,  1.    ,  0.    ],</span>
<span class="sd">    ...               [ 0.,   0. ,  0.    ,  1.    ],</span>
<span class="sd">    ...               [-1.4,  1.2, -0.0058,  0.0014],</span>
<span class="sd">    ...               [ 0.8, -1.4,  0.0016, -0.0038]])</span>
<span class="sd">    &gt;&gt;&gt; B = np.array([[ 0.],</span>
<span class="sd">    ...               [ 0.],</span>
<span class="sd">    ...               [ 0.],</span>
<span class="sd">    ...               [ 1.]])</span>
<span class="sd">    &gt;&gt;&gt; C = np.array([[-1.4, 1.2, -0.0058, 0.0014]])</span>
<span class="sd">    &gt;&gt;&gt; D = np.array([[-0.2]])</span>
<span class="sd">    &gt;&gt;&gt; omega, H = vt.ssfrf(A, B, C, D, 0, 3.5, 1, 1)</span>
<span class="sd">    &gt;&gt;&gt; vt.frfplot(omega, H) # doctest: +SKIP</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">C</span><span class="p">,</span> <span class="n">D</span> <span class="o">=</span> <span class="n">so2ss</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="n">C</span><span class="p">,</span> <span class="n">K</span><span class="p">,</span> <span class="n">Bt</span><span class="p">,</span> <span class="n">Cd</span><span class="p">,</span> <span class="n">Cv</span><span class="p">,</span> <span class="n">Ca</span><span class="p">)</span>

    <span class="n">omega</span><span class="p">,</span> <span class="n">H</span> <span class="o">=</span> <span class="n">ssfrf</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">C</span><span class="p">,</span> <span class="n">D</span><span class="p">,</span> <span class="n">omega_low</span><span class="p">,</span> <span class="n">omega_high</span><span class="p">,</span> <span class="n">in_index</span><span class="p">,</span> <span class="n">out_index</span><span class="p">,</span>
                     <span class="n">num_freqs</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">omega</span><span class="p">,</span> <span class="n">H</span></div>


<div class="viewcode-block" id="so2ss"><a class="viewcode-back" href="../reference/system.html#system.so2ss">[docs]</a><span class="k">def</span> <span class="nf">so2ss</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="n">C</span><span class="p">,</span> <span class="n">K</span><span class="p">,</span> <span class="n">Bt</span><span class="p">,</span> <span class="n">Cd</span><span class="p">,</span> <span class="n">Cv</span><span class="p">,</span> <span class="n">Ca</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Convert second order system to state space.</span>

<span class="sd">    Given second order linear matrix equation of the form</span>
<span class="sd">    :math:`M\\ddot{x} + C \\dot{x} + K x= \\tilde{B} u`</span>
<span class="sd">    and</span>
<span class="sd">    :math:`y = C_d x + C_v \\dot{x} + C_a\\ddot{x}`</span>
<span class="sd">    returns the state space form equations</span>
<span class="sd">    :math:`\\dot{z} = A z + B u`,</span>
<span class="sd">    :math:`y = C z + D u`</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    M, C, K, Bt, Cd, Cv, Cd : float arrays</span>
<span class="sd">        Mass , damping, stiffness, input, displacement sensor, velocimeter,</span>
<span class="sd">        and accelerometer matrices</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    A, B, C, D : float arrays</span>
<span class="sd">        State matrices</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; import vibrationtesting as vt</span>
<span class="sd">    &gt;&gt;&gt; M = np.array([[2, 1],</span>
<span class="sd">    ...               [1, 3]])</span>
<span class="sd">    &gt;&gt;&gt; K = np.array([[2, -1],</span>
<span class="sd">    ...               [-1, 3]])</span>
<span class="sd">    &gt;&gt;&gt; C = np.array([[0.01, 0.001],</span>
<span class="sd">    ...               [0.001, 0.01]])</span>
<span class="sd">    &gt;&gt;&gt; Bt = np.array([[0], [1]])</span>
<span class="sd">    &gt;&gt;&gt; Cd = Cv = np.zeros((1,2))</span>
<span class="sd">    &gt;&gt;&gt; Ca = np.array([[1, 0]])</span>
<span class="sd">    &gt;&gt;&gt; A, B, Css, D = vt.so2ss(M, C, K, Bt, Cd, Cv, Ca)</span>
<span class="sd">    &gt;&gt;&gt; print(&#39;A: {}&#39;.format(A))</span>
<span class="sd">    A:  [[ 0.      0.      1.      0.    ]</span>
<span class="sd">     [ 0.      0.      0.      1.    ]</span>
<span class="sd">     [-1.4     1.2    -0.0058  0.0014]</span>
<span class="sd">     [ 0.8    -1.4     0.0016 -0.0038]]</span>
<span class="sd">    &gt;&gt;&gt; print(&#39;B: &#39;, B)</span>
<span class="sd">    B:  [[ 0. ]</span>
<span class="sd">     [ 0. ]</span>
<span class="sd">     [-0.2]</span>
<span class="sd">     [ 0.4]]</span>
<span class="sd">    &gt;&gt;&gt; print(&#39;C: &#39;, Css)</span>
<span class="sd">    C:  [[-1.4     1.2    -0.0058  0.0014]]</span>
<span class="sd">    &gt;&gt;&gt; print(&#39;D: &#39;, D)</span>
<span class="sd">    D:  [[-0.2]]</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">A</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">M</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="n">M</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]))),</span>
                   <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="o">-</span><span class="n">la</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="n">K</span><span class="p">),</span> <span class="o">-</span><span class="n">la</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="n">C</span><span class="p">)))))</span>
    <span class="n">B</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">Bt</span><span class="p">),</span> <span class="n">la</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="n">Bt</span><span class="p">)))</span>
<div class="viewcode-block" id="damp"><a class="viewcode-back" href="../reference/system.html#system.damp">[docs]</a>    <span class="n">C_ss</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">Cd</span> <span class="o">-</span> <span class="n">Ca</span><span class="nd">@la</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="n">K</span><span class="p">),</span> <span class="n">Cv</span> <span class="o">-</span> <span class="n">Ca</span><span class="nd">@la</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="n">C</span><span class="p">)))</span>
    <span class="n">D</span> <span class="o">=</span> <span class="n">Ca</span><span class="nd">@la</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="n">Bt</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">C_ss</span><span class="p">,</span> <span class="n">D</span></div>


<span class="k">def</span> <span class="nf">damp</span><span class="p">(</span><span class="n">A</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Display natural frequencies and damping ratios of state matrix.&quot;&quot;&quot;</span>
    <span class="c1"># Original Author: Kai P. Mueller &lt;mueller@ifr.ing.tu-bs.de&gt; for Octave</span>
    <span class="c1"># Created: September 29, 1997.</span>

    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;............... Eigenvalue ...........     Damping     Frequency&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;--------[re]---------[im]--------[abs]----------------------[Hz]&quot;</span><span class="p">)</span>
    <span class="n">e</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">la</span><span class="o">.</span><span class="n">eig</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">e</span><span class="p">)):</span>
        <span class="n">pole</span> <span class="o">=</span> <span class="n">e</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>

        <span class="n">d0</span> <span class="o">=</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">atan2</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">imag</span><span class="p">(</span><span class="n">pole</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">pole</span><span class="p">)))</span>
        <span class="n">f0</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="nb">abs</span><span class="p">(</span><span class="n">pole</span><span class="p">)</span>
        <span class="k">if</span> <span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">imag</span><span class="p">(</span><span class="n">pole</span><span class="p">))</span> <span class="o">&lt;</span> <span class="nb">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">pole</span><span class="p">))):</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;      </span><span class="si">{:.3f}</span><span class="s1">                    </span><span class="si">{:.3f}</span><span class="s1">       </span><span class="se">\</span>
<span class="s1">                  </span><span class="si">{:.3f}</span><span class="s1">         </span><span class="si">{:.3f}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">pole</span><span class="p">)),</span>
                                                <span class="nb">float</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">pole</span><span class="p">)),</span> <span class="nb">float</span><span class="p">(</span><span class="n">d0</span><span class="p">),</span>
                                                <span class="nb">float</span><span class="p">(</span><span class="n">f0</span><span class="p">)))</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;      </span><span class="si">{:.3f}</span><span class="s1">        </span><span class="si">{:+.3f}</span><span class="s1">      </span><span class="si">{:.3f}</span><span class="s1">       </span><span class="se">\</span>
<span class="s1">                  </span><span class="si">{:.3f}</span><span class="s1">         </span><span class="si">{:.3f}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">pole</span><span class="p">)),</span>
                                                <span class="nb">float</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">imag</span><span class="p">(</span><span class="n">pole</span><span class="p">)),</span> <span class="nb">float</span><span class="p">(</span>
                                                    <span class="nb">abs</span><span class="p">(</span><span class="n">pole</span><span class="p">)),</span> <span class="nb">float</span><span class="p">(</span><span class="n">d0</span><span class="p">),</span>
                                                <span class="nb">float</span><span class="p">(</span><span class="n">f0</span><span class="p">)))</span></div>


<div class="viewcode-block" id="sos_modal"><a class="viewcode-back" href="../reference/system.html#system.sos_modal">[docs]</a><span class="k">def</span> <span class="nf">sos_modal</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="n">K</span><span class="p">,</span> <span class="n">C</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">damp_diag</span><span class="o">=</span><span class="mf">0.03</span><span class="p">,</span> <span class="n">shift</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Eigen analysis of proportionally damped system.</span>

<span class="sd">    Optimally find mass normalized mode shapes and natural frequencies</span>
<span class="sd">    of a system modelled by :math:`M\ddot{x}+Kx=0`.</span>

<span class="sd">    If provided, obtain damping ratios presuming :math:`C` can be decoupled.</span>

<span class="sd">    Provides a warning if diagonalization of damping matrix fails worse than</span>
<span class="sd">    relative error of `damp_diag`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    M, K : float arrays</span>
<span class="sd">        Mass and stiffness matrices</span>
<span class="sd">    C : float array, optional</span>
<span class="sd">        Damping matrix</span>
<span class="sd">    damp_diag : float, optional</span>
<span class="sd">        Maximum amount of off-diagonal error allowed in assuming C can be</span>
<span class="sd">        diagonalized</span>
<span class="sd">    shift : float, optional</span>
<span class="sd">        Shift used in eigensolution. Should be approximately equal to the first</span>
<span class="sd">        non-zero eigenvalue.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    omega : float array (1xN)</span>
<span class="sd">        Vector of natural frequencies (rad/sec)</span>
<span class="sd">    zeta : float array (1xN)</span>
<span class="sd">        Vector of damping ratios</span>
<span class="sd">    Psi : float array (NxN)</span>
<span class="sd">        Matrix of mass normalized mode shapes by column</span>


<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; import numpy as np</span>
<span class="sd">    &gt;&gt;&gt; import vibrationtesting as vt</span>
<span class="sd">    &gt;&gt;&gt; M = np.array([[4, 0, 0],</span>
<span class="sd">    ...               [0, 4, 0],</span>
<span class="sd">    ...               [0, 0, 4]])</span>
<span class="sd">    &gt;&gt;&gt; K = np.array([[8, -4, 0],</span>
<span class="sd">    ...               [-4, 8, -4],</span>
<span class="sd">    ...               [0, -4, 4]])</span>
<span class="sd">    &gt;&gt;&gt; omega, zeta, Psi = vt.sos_modal(M, K, K/10)</span>
<span class="sd">    &gt;&gt;&gt; print(omega)</span>
<span class="sd">    [ 0.445   1.247   1.8019]</span>
<span class="sd">    &gt;&gt;&gt; print(Psi.T@K@Psi)</span>
<span class="sd">    [[ 0.1981  0.     -0.    ]</span>
<span class="sd">     [ 0.      1.555  -0.    ]</span>
<span class="sd">     [-0.     -0.      3.247 ]]</span>

<span class="sd">    Check that it works for rigid body modes.</span>

<span class="sd">    &gt;&gt;&gt; K2 = K-np.eye(K.shape[0])@M*(Psi.T@K@Psi)[0,0]</span>
<span class="sd">    &gt;&gt;&gt; omega, zeta, Psi = vt.sos_modal(M, K2)</span>
<span class="sd">    &gt;&gt;&gt; print(omega)</span>
<span class="sd">    [ 0.      1.1649  1.7461]</span>
<span class="sd">    &gt;&gt;&gt; print(Psi)</span>
<span class="sd">    [[-0.164   0.3685 -0.2955]</span>
<span class="sd">     [-0.2955  0.164   0.3685]</span>
<span class="sd">     [-0.3685 -0.2955 -0.164 ]]</span>
<span class="sd">    &gt;&gt;&gt; print(np.diag(Psi.T@K2@Psi))</span>
<span class="sd">    [ 0.      1.3569  3.0489]</span>

<span class="sd">    How about non-proportional damping</span>

<span class="sd">    &gt;&gt;&gt; C = K/10</span>
<span class="sd">    &gt;&gt;&gt; C[0,0] = 2 * C[0,0]</span>
<span class="sd">    &gt;&gt;&gt; omega, zeta, Psi = vt.sos_modal(M, K2, C)</span>
<span class="sd">    Damping matrix cannot be completely diagonalized.</span>
<span class="sd">    Off diagonal error of 22%.</span>
<span class="sd">    &gt;&gt;&gt; print(omega)</span>
<span class="sd">    [ 0.      1.1649  1.7461]</span>
<span class="sd">    &gt;&gt;&gt; print(zeta)</span>
<span class="sd">    [ 0.      0.1134  0.113 ]</span>
<span class="sd">    &gt;&gt;&gt; print(Psi.T@C@Psi)</span>
<span class="sd">    [[ 0.0413 -0.0483  0.0388]</span>
<span class="sd">     [-0.0483  0.2641 -0.0871]</span>
<span class="sd">     [ 0.0388 -0.0871  0.3946]]</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">K</span> <span class="o">=</span> <span class="n">K</span> <span class="o">+</span> <span class="n">M</span> <span class="o">*</span> <span class="n">shift</span>

    <span class="n">lam</span><span class="p">,</span> <span class="n">Psi</span> <span class="o">=</span> <span class="n">la</span><span class="o">.</span><span class="n">eigh</span><span class="p">(</span><span class="n">K</span><span class="p">,</span> <span class="n">M</span><span class="p">)</span>

    <span class="n">omega</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">lam</span> <span class="o">-</span> <span class="n">shift</span><span class="p">))</span>  <span class="c1"># round to zero</span>

<div class="viewcode-block" id="serep"><a class="viewcode-back" href="../reference/system.html#system.serep">[docs]</a>    <span class="n">norms</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="mf">1.0</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">Psi</span><span class="o">.</span><span class="n">T</span><span class="nd">@M@Psi</span><span class="p">)))</span>

    <span class="n">Psi</span> <span class="o">=</span> <span class="n">Psi</span> <span class="o">@</span> <span class="n">norms</span>

    <span class="n">zeta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">omega</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">C</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">False</span><span class="p">:</span>
        <span class="n">diagonalized_C</span> <span class="o">=</span> <span class="n">Psi</span><span class="o">.</span><span class="n">T</span><span class="nd">@C@Psi</span>

        <span class="n">diagonal_C</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">diagonalized_C</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">min</span><span class="p">(</span><span class="n">omega</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mf">1e-5</span><span class="p">:</span>
            <span class="n">zeta</span> <span class="o">=</span> <span class="n">diagonal_C</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">/</span> <span class="n">omega</span>  <span class="c1"># error if omega = 0</span>
            <span class="n">max_off_diagonals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">amax</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">diagonalized_C</span>
                                               <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">diagonal_C</span><span class="p">)),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="c1"># error if no damping</span>
            <span class="n">damp_error</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">max_off_diagonals</span> <span class="o">/</span> <span class="n">diagonal_C</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">zeta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">omega</span><span class="p">)</span>
            <span class="n">damp_error</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">omega</span><span class="p">)</span>
            <span class="n">de_diag_C</span> <span class="o">=</span> <span class="n">diagonalized_C</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">diagonal_C</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">mode_num</span><span class="p">,</span> <span class="n">omega_i</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">omega</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">omega</span><span class="p">[</span><span class="n">mode_num</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mf">1e-5</span><span class="p">:</span>
                    <span class="n">zeta</span><span class="p">[</span><span class="n">mode_num</span><span class="p">]</span> <span class="o">=</span> <span class="n">diagonal_C</span><span class="p">[</span><span class="n">mode_num</span><span class="p">]</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">/</span> <span class="n">omega_i</span>
                    <span class="n">damp_error</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">de_diag_C</span><span class="p">[:,</span> <span class="n">mode_num</span><span class="p">]))</span>
                                  <span class="o">/</span> <span class="n">diagonal_C</span><span class="p">[</span><span class="n">mode_num</span><span class="p">])</span>

        <span class="k">if</span> <span class="n">damp_error</span> <span class="o">&gt;</span> <span class="n">damp_diag</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Damping matrix cannot be completely diagonalized.&#39;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Off diagonal error of </span><span class="si">{:4.0%}</span><span class="s1">.&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">damp_error</span><span class="p">))</span>

    <span class="k">return</span> <span class="n">omega</span><span class="p">,</span> <span class="n">zeta</span><span class="p">,</span> <span class="n">Psi</span></div>


<span class="k">def</span> <span class="nf">serep</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="n">K</span><span class="p">,</span> <span class="n">master</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;System Equivalent Reduction Expansion Process reduced model.</span>

<span class="sd">    Reduce size of second order system of equations by SEREP processs while</span>
<span class="sd">    returning expansion matrix</span>

<span class="sd">    Equation of the form:</span>
<span class="sd">    :math:`M \ddot{x} + K x = 0`</span>
<span class="sd">    is reduced to the form</span>
<span class="sd">    :math:`M_r \ddot{x}_m + Kr x_m = 0`</span>
<span class="sd">    where :math:`x = T x_m`, :math:`M_r= T^T M T`, :math:`K_r= T^T K T`</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    M, K : float arrays</span>
<span class="sd">        Mass and Stiffness matrices</span>
<span class="sd">    master : float array or list</span>
<span class="sd">        List of retained degrees of freedom</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    Mred, Kred, T : float arrays</span>
<span class="sd">        Reduced Mass matric, reduced stiffness matrix, Transformation matrix</span>
<span class="sd">    truncated_dofs : int list</span>
<span class="sd">        List of truncated degrees of freedom, zero indexed</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; import vibrationtesting as vt</span>
<span class="sd">    &gt;&gt;&gt; M = np.array([[4, 0, 0],</span>
<span class="sd">    ...               [0, 4, 0],</span>
<span class="sd">    ...               [0, 0, 4]])</span>
<span class="sd">    &gt;&gt;&gt; K = np.array([[8, -4, 0],</span>
<span class="sd">    ...               [-4, 8, -4],</span>
<span class="sd">    ...               [0, -4, 4]])</span>
<span class="sd">    &gt;&gt;&gt; retained = np.array([[1, 2]])</span>
<span class="sd">    &gt;&gt;&gt; Mred, Kred, T, truncated_dofs = vt.serep(M, K, retained)</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    Reduced coordinate system forces can be obtained by</span>
<span class="sd">    `Fr = T.T @ F`</span>

<span class="sd">    Reduced damping matrix can be obtained using `Cr = T.T*@ C @ T`.</span>

<span class="sd">    If mode shapes are obtained for the reduced system, full system mode shapes</span>
<span class="sd">    are `phi = T @ phi_r`</span>

<span class="sd">    .. seealso:: :func:`guyan`</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">nm</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="n">master</span><span class="o">.</span><span class="n">shape</span><span class="p">))</span>  <span class="c1"># number of modes to keep;</span>
    <span class="n">master</span> <span class="o">=</span> <span class="n">master</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>  <span class="c1"># retained dofs</span>

    <span class="n">ndof</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">M</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>  <span class="c1"># length(M);</span>

    <span class="n">omega</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">Psi</span> <span class="o">=</span> <span class="n">sos_modal</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="n">K</span><span class="p">)</span>
    <span class="n">Psi_tr</span> <span class="o">=</span> <span class="n">Psi</span><span class="p">[</span><span class="n">nm</span><span class="p">:,</span> <span class="p">:</span><span class="n">nm</span><span class="p">]</span>  <span class="c1"># Truncated modes</span>
    <span class="n">Psi_rr</span> <span class="o">=</span> <span class="n">Psi</span><span class="p">[:</span><span class="n">nm</span><span class="p">,</span> <span class="p">:</span><span class="n">nm</span><span class="p">]</span>  <span class="c1"># Retained modes</span>

    <span class="n">truncated_dofs</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">ndof</span><span class="p">))</span> <span class="o">-</span> <span class="nb">set</span><span class="p">(</span><span class="n">master</span><span class="p">))</span>

    <span class="n">T</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">ndof</span><span class="p">,</span> <span class="n">nm</span><span class="p">))</span>
    <span class="n">T</span><span class="p">[</span><span class="n">master</span><span class="p">,</span> <span class="p">:</span><span class="n">nm</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="n">nm</span><span class="p">)</span>
    <span class="n">T</span><span class="p">[</span><span class="n">truncated_dofs</span><span class="p">,</span> <span class="p">:</span><span class="n">nm</span><span class="p">]</span> <span class="o">=</span> <span class="n">la</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">Psi_rr</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">Psi_tr</span><span class="o">.</span><span class="n">T</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>
<div class="viewcode-block" id="guyan"><a class="viewcode-back" href="../reference/system.html#system.guyan">[docs]</a>    <span class="n">Mred</span> <span class="o">=</span> <span class="n">T</span><span class="o">.</span><span class="n">T</span> <span class="o">@</span> <span class="n">M</span> <span class="nd">@T</span>
    <span class="n">Kred</span> <span class="o">=</span> <span class="n">T</span><span class="o">.</span><span class="n">T</span> <span class="o">@</span> <span class="n">K</span> <span class="nd">@T</span>

    <span class="k">return</span> <span class="n">Mred</span><span class="p">,</span> <span class="n">Kred</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">truncated_dofs</span><span class="p">)</span></div>


<span class="k">def</span> <span class="nf">guyan</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="n">K</span><span class="p">,</span> <span class="n">master</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">fraction</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Guyan reduced model.</span>

<span class="sd">    Applies Guyan Reductions to second order system of equations of the form</span>

<span class="sd">    .. math:: M \ddot{x} + K x = 0</span>

<span class="sd">    which are reduced to the form</span>

<span class="sd">    .. math:: M_r \ddot{x}_m + K_r x_m = 0</span>

<span class="sd">    where</span>

<span class="sd">    .. math::</span>

<span class="sd">        x = T x_m</span>

<span class="sd">        M_r= T^T M T</span>

<span class="sd">        K_r= T^T K T</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    M, K : float arrays</span>
<span class="sd">        Mass and Stiffness matrices</span>
<span class="sd">    master : float array or list, optional</span>
<span class="sd">        List of retained degrees of freedom (0 indexing)</span>
<span class="sd">    fraction : float, optional</span>
<span class="sd">        Fraction of degrees of freedom (0&lt; `fraction` &lt;1.0) to retain in model.</span>
<span class="sd">        If both master and fraction are neglected, fraction is set to 0.25.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    Mred, Kred, T : float arrays</span>
<span class="sd">        Reduced Mass matric, Reduced Stiffness matrix, Transformation matrix</span>
<span class="sd">    master_dofs : int list</span>
<span class="sd">        List of master degrees of freedom (0 indexing)</span>
<span class="sd">    truncated_dofs : int list</span>
<span class="sd">        List of truncated degrees of freedom (0 indexing)</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; import vibrationtesting as vt</span>
<span class="sd">    &gt;&gt;&gt; M = np.array([[4, 0, 0],</span>
<span class="sd">    ...               [0, 4, 0],</span>
<span class="sd">    ...               [0, 0, 4]])</span>
<span class="sd">    &gt;&gt;&gt; K = np.array([[8, -4, 0],</span>
<span class="sd">    ...               [-4, 8, -4],</span>
<span class="sd">    ...               [0, -4, 4]])</span>
<span class="sd">    &gt;&gt;&gt; Mred, Kred, T, master, truncated_dofs = vt.guyan(M, K, fraction = 0.5)</span>


<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    Reduced coordinate system forces can be obtained by `Fr = T.T @ F`.</span>

<span class="sd">    Reduced damping matrix can be obtained using `Cr = T.T @ C @ T`.</span>

<span class="sd">    If mode shapes are obtained for the reduced system, full system mode shapes</span>
<span class="sd">    are `phi = T @ phi_r`.</span>

<span class="sd">    Code is not as efficient as possible. Using block submatrices would be</span>
<span class="sd">    more efficient.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">master</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">fraction</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">fraction</span> <span class="o">=</span> <span class="mf">0.25</span>

        <span class="n">ratios</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">M</span><span class="p">)</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">K</span><span class="p">)</span>
        <span class="n">ranked</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="nb">enumerate</span><span class="p">(</span><span class="n">ratios</span><span class="p">),</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">])]</span>
        <span class="n">thresh</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">fraction</span> <span class="o">*</span> <span class="n">ratios</span><span class="o">.</span><span class="n">size</span><span class="p">)</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">thresh</span> <span class="o">&gt;=</span> <span class="n">ratios</span><span class="o">.</span><span class="n">size</span><span class="p">)</span> <span class="ow">or</span> <span class="n">thresh</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Can&#39;t keep&quot;</span><span class="p">,</span> <span class="n">thresh</span><span class="p">,</span> <span class="s1">&#39;DOFs.&#39;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Fraction of&quot;</span><span class="p">,</span> <span class="n">fraction</span><span class="p">,</span> <span class="s2">&quot;is too low or too high.&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span>

        <span class="n">master</span> <span class="o">=</span> <span class="n">ranked</span><span class="p">[</span><span class="o">-</span><span class="n">thresh</span><span class="p">:]</span>

    <span class="n">master</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">master</span><span class="p">)</span>
    <span class="n">nm</span> <span class="o">=</span> <span class="n">master</span><span class="o">.</span><span class="n">size</span>  <span class="c1"># number of dofs to keep;</span>
    <span class="n">master</span> <span class="o">=</span> <span class="n">master</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>   <span class="c1"># retained dofs</span>

    <span class="n">ndof</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">M</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>  <span class="c1"># length(M);</span>

    <span class="n">truncated_dofs</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">ndof</span><span class="p">))</span> <span class="o">-</span> <span class="nb">set</span><span class="p">(</span><span class="n">master</span><span class="p">))</span>
    <span class="c1"># truncated_dofs = np.array(set(np.arange(ndof)) - set(master))</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Mmm = M[master].T[master].T</span>
<span class="sd">    Kmm = K[master].T[master].T</span>
<span class="sd">    Mtm = M[truncated_dofs].T[master].T</span>
<span class="sd">    Ktm = K[truncated_dofs].T[master].T</span>
<span class="sd">    Mtt = M[truncated_dofs].T[truncated_dofs].T</span>
<span class="sd">    Ktt = K[truncated_dofs].T[truncated_dofs].T&quot;&quot;&quot;</span>

    <span class="c1"># Mmm = slice(M, master, master)</span>
    <span class="c1"># Kmm = slice(K, master, master)</span>
    <span class="c1"># Mtm = slice(M, truncated_dofs, master)</span>
    <span class="n">Ktm</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="n">K</span><span class="p">,</span> <span class="n">truncated_dofs</span><span class="p">,</span> <span class="n">master</span><span class="p">)</span>
    <span class="c1"># Mtt = slice(M, truncated_dofs, truncated_dofs)</span>
    <span class="n">Ktt</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="n">K</span><span class="p">,</span> <span class="n">truncated_dofs</span><span class="p">,</span> <span class="n">truncated_dofs</span><span class="p">)</span>

    <span class="n">T</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">ndof</span><span class="p">,</span> <span class="n">nm</span><span class="p">))</span>
    <span class="n">T</span><span class="p">[</span><span class="n">master</span><span class="p">,</span> <span class="p">:</span><span class="n">nm</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="n">nm</span><span class="p">)</span>
    <span class="n">T</span><span class="p">[</span><span class="n">truncated_dofs</span><span class="p">,</span> <span class="p">:</span><span class="n">nm</span><span class="p">]</span> <span class="o">=</span> <span class="n">la</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="o">-</span><span class="n">Ktt</span><span class="p">,</span> <span class="n">Ktm</span><span class="p">)</span>
<div class="viewcode-block" id="mode_expansion_from_model"><a class="viewcode-back" href="../reference/system.html#system.mode_expansion_from_model">[docs]</a>    <span class="n">Mred</span> <span class="o">=</span> <span class="n">T</span><span class="o">.</span><span class="n">T</span> <span class="o">@</span> <span class="n">M</span> <span class="o">@</span> <span class="n">T</span>
    <span class="n">Kred</span> <span class="o">=</span> <span class="n">T</span><span class="o">.</span><span class="n">T</span> <span class="o">@</span> <span class="n">K</span> <span class="o">@</span> <span class="n">T</span>
    <span class="k">return</span> <span class="n">Mred</span><span class="p">,</span> <span class="n">Kred</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">master</span><span class="p">,</span> <span class="n">truncated_dofs</span></div>


<span class="k">def</span> <span class="nf">mode_expansion_from_model</span><span class="p">(</span><span class="n">Psi</span><span class="p">,</span> <span class="n">omega</span><span class="p">,</span> <span class="n">M</span><span class="p">,</span> <span class="n">K</span><span class="p">,</span> <span class="n">measured</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Deflection extrapolation to full FEM model coordinates, matrix method.</span>

<span class="sd">    Provided an equation  of the form:</span>

<span class="sd">    :math:`\begin{pmatrix}-\begin{bmatrix}M_{mm}&amp;M_{mu}\\ M_{um}&amp;M_{uu}</span>
<span class="sd">    \end{bmatrix} \omega_i^2</span>
<span class="sd">    +\begin{bmatrix}K_{mm}&amp;K_{mu}\\ K_{um}&amp;K_{uu}\end{bmatrix}\end{pmatrix}`</span>
<span class="sd">    :math:`\begin{bmatrix}\Psi_{i_m}\\ \Psi_{i_u}\end{bmatrix}= 0`</span>

<span class="sd">    Where:</span>

<span class="sd">    - :math:`M` and :math:`K` are the mass and stiffness matrices, likely from</span>
<span class="sd">      a finite element model</span>
<span class="sd">    - :math:`\Psi_i` and :math:`\omega_i` represent a mode/frequency pair</span>
<span class="sd">    - subscripts :math:`m` and :math:`u` represent measure and unmeasured</span>
<span class="sd">      of the mode</span>

<span class="sd">    Determines the unknown portion of the mode (or operational deflection)</span>
<span class="sd">    shape, :math:`\Psi_{i_u}` by</span>
<span class="sd">    direct algebraic solution, aka</span>

<span class="sd">    :math:`\Psi_{i_u} = - (K_{uu}- M_{ss} \omega_i^2) ^{-1}</span>
<span class="sd">    (K_{um}-M_{um}\omega_i^2)\Psi_{i_m}`</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    Psi : float array</span>
<span class="sd">        mode shape or shapes, 2-D array columns of which are mode shapes</span>
<span class="sd">    omega : float or 1-D float array</span>
<span class="sd">        natural (or driving) frequencies</span>
<span class="sd">    M, K : float arrays</span>
<span class="sd">        Mass and Stiffness matrices</span>
<span class="sd">    measured : float or integer array or list</span>
<span class="sd">        List of measured degrees of freedom (0 indexed)</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    Psi_full : float array</span>
<span class="sd">        Complete mode shape</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; import vibrationtesting as vt</span>
<span class="sd">    &gt;&gt;&gt; M = np.array([[4, 0, 0],</span>
<span class="sd">    ...               [0, 4, 0],</span>
<span class="sd">    ...               [0, 0, 4]])</span>
<span class="sd">    &gt;&gt;&gt; K = np.array([[8, -4, 0],</span>
<span class="sd">    ...               [-4, 8, -4],</span>
<span class="sd">    ...               [0, -4, 4]])</span>
<span class="sd">    &gt;&gt;&gt; measured = np.array([[0, 2]])</span>
<span class="sd">    &gt;&gt;&gt; omega, zeta, Psi = vt.sos_modal(M, K)</span>
<span class="sd">    &gt;&gt;&gt; Psi_measured = np.array([[-0.15], [-0.37]])</span>
<span class="sd">    &gt;&gt;&gt; Psi_full = vt.mode_expansion_from_model(Psi_measured, omega[0], M, K,</span>
<span class="sd">    ... measured)</span>
<span class="sd">    &gt;&gt;&gt; print(np.hstack((Psi[:,0].reshape(-1,1), Psi_full)))</span>
<span class="sd">    [[-0.164  -0.15  ]</span>
<span class="sd">     [-0.2955  0.2886]</span>
<span class="sd">     [-0.3685 -0.37  ]]</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    .. seealso:: incomplete multi-mode update. Would require each at a</span>
<span class="sd">      different frequency.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">measured</span> <span class="o">=</span> <span class="n">measured</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>  <span class="c1"># retained dofs</span>
    <span class="n">num_measured</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">measured</span><span class="p">)</span>
    <span class="n">ndof</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">M</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>  <span class="c1"># length(M);</span>
    <span class="n">unmeasured_dofs</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">ndof</span><span class="p">))</span> <span class="o">-</span> <span class="nb">set</span><span class="p">(</span><span class="n">measured</span><span class="p">))</span>
    <span class="n">num_unmeasured</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">unmeasured_dofs</span><span class="p">)</span>

    <span class="c1"># Code from before my slicing code</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Muu = np.array(M[unmeasured_dofs].T[unmeasured_dofs].T).</span>
<span class="sd">                   reshape(num_unmeasured, num_unmeasured)</span>

<span class="sd">    Kuu = np.array(K[unmeasured_dofs].T[unmeasured_dofs].T)</span>
<span class="sd">                   .reshape(num_unmeasured, num_unmeasured)</span>
<span class="sd">    Mum = np.array(M[unmeasured_dofs].T[measured].T).reshape(num_unmeasured,</span>
<span class="sd">                                                         num_measured)</span>
<span class="sd">    Kum = np.array(K[unmeasured_dofs].T[measured].T).reshape(num_unmeasured,</span>
<span class="sd">                                                         num_measured)</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">Muu</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="n">unmeasured_dofs</span><span class="p">,</span> <span class="n">unmeasured_dofs</span><span class="p">)</span>
    <span class="n">Kuu</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="n">K</span><span class="p">,</span> <span class="n">unmeasured_dofs</span><span class="p">,</span> <span class="n">unmeasured_dofs</span><span class="p">)</span>
    <span class="n">Mum</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="n">unmeasured_dofs</span><span class="p">,</span> <span class="n">measured</span><span class="p">)</span>
    <span class="n">Kum</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="n">K</span><span class="p">,</span> <span class="n">unmeasured_dofs</span><span class="p">,</span> <span class="n">measured</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">omega</span><span class="p">,</span> <span class="nb">float</span><span class="p">):</span>
        <span class="n">omega</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">omega</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>

    <span class="n">Psi_full</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">num_measured</span> <span class="o">+</span> <span class="n">num_unmeasured</span><span class="p">,</span> <span class="n">Psi</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
    <span class="n">Psi_full</span><span class="p">[</span><span class="n">measured</span><span class="p">]</span> <span class="o">=</span> <span class="n">Psi</span>

    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">omega_n</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">omega</span><span class="p">):</span>
        <span class="n">Psi_i</span> <span class="o">=</span> <span class="n">Psi</span><span class="p">[:,</span> <span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">Psi_unmeasured</span> <span class="o">=</span> <span class="n">la</span><span class="o">.</span><span class="n">solve</span><span class="p">((</span><span class="n">Kuu</span> <span class="o">-</span> <span class="n">Muu</span> <span class="o">*</span> <span class="n">omega_n</span><span class="o">**</span><span class="mi">2</span><span class="p">),</span>
<div class="viewcode-block" id="improved_reduction"><a class="viewcode-back" href="../reference/system.html#system.improved_reduction">[docs]</a>                                  <span class="p">(</span><span class="n">Kum</span> <span class="o">-</span> <span class="n">Mum</span> <span class="o">*</span> <span class="n">omega_n</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="nd">@Psi_i</span><span class="p">)</span>
        <span class="n">Psi_full</span><span class="p">[</span><span class="n">unmeasured_dofs</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">Psi_unmeasured</span>
        <span class="c1"># Psi_full = Psi_full.reshape(-1, 1)</span>
    <span class="k">return</span> <span class="n">Psi_full</span></div>


<span class="k">def</span> <span class="nf">improved_reduction</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="n">K</span><span class="p">,</span> <span class="n">master</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">fraction</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Incomplete.</span>

<span class="sd">    4.14 Friswell</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;not written yet&#39;</span><span class="p">)</span>
    <span class="k">return</span></div>


<div class="viewcode-block" id="model_correction_direct"><a class="viewcode-back" href="../reference/system.html#system.model_correction_direct">[docs]</a><span class="k">def</span> <span class="nf">model_correction_direct</span><span class="p">(</span><span class="n">Psi</span><span class="p">,</span> <span class="n">omega</span><span class="p">,</span> <span class="n">M</span><span class="p">,</span> <span class="n">K</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;Baruch&#39;</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Direct model updating using model data.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    Psi : float array</span>
<span class="sd">        Expanded mode shapes from experimental measurements. Must be</span>
<span class="sd">        real-valued. See `mode_expansion_from_model`.</span>
<span class="sd">    omega : float array</span>
<span class="sd">        Natural frequencies identified from modal analysis (diagonal matrix or</span>
<span class="sd">        vector).</span>
<span class="sd">    M, K : float arrays</span>
<span class="sd">        Analytical mass and stiffness matrices</span>
<span class="sd">    method : string, optional</span>
<span class="sd">        `Baruch` and Bar-Itzhack [1]_ or `Berman` and Nagy [2]_</span>
<span class="sd">        (default Baruch)</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    Mc, Kc : float arrays</span>
<span class="sd">        Corrected mass and stiffness matrices.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    .. [1] Baruch, M. and Bar-Itzhack, I.Y., &quot;Optimal Weighted</span>
<span class="sd">       Orthogonalization of Measured Modes,&quot; *AIAA Journal*, 16(4), 1978, pp.</span>
<span class="sd">       346-351.</span>
<span class="sd">    .. [2] Berman, A. and Nagy, E.J., 1983, &quot;Improvements of a Large Analytical</span>
<span class="sd">       Model using Test Data,&quot; *AIAA Journal*, 21(8), 1983, pp. 1168-1173.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">omega</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">omega</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">omega</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">omega</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">omega</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
        <span class="n">omega</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">omega</span><span class="p">)</span>

<div class="viewcode-block" id="slice"><a class="viewcode-back" href="../reference/system.html#system.slice">[docs]</a>    <span class="n">lam</span> <span class="o">=</span> <span class="n">omega</span> <span class="o">@</span> <span class="n">omega</span>

    <span class="k">if</span> <span class="n">method</span> <span class="ow">is</span> <span class="s1">&#39;Berman&#39;</span><span class="p">:</span>

        <span class="n">Mdiag</span> <span class="o">=</span> <span class="n">Psi</span><span class="o">.</span><span class="n">T</span><span class="nd">@M@Psi</span>
        <span class="n">eye_size</span> <span class="o">=</span> <span class="n">Mdiag</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">Mc</span> <span class="o">=</span> <span class="p">(</span><span class="n">M</span> <span class="o">+</span> <span class="n">M</span> <span class="o">@</span> <span class="n">Psi</span> <span class="o">@</span> <span class="n">la</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">Mdiag</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="n">eye_size</span><span class="p">)</span> <span class="o">-</span> <span class="n">Mdiag</span><span class="p">)</span>
              <span class="o">@</span> <span class="n">la</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">Mdiag</span><span class="p">,</span> <span class="n">Psi</span><span class="o">.</span><span class="n">T</span><span class="p">)</span> <span class="o">@</span> <span class="n">M</span><span class="p">)</span>

        <span class="n">Kc</span> <span class="o">=</span> <span class="p">(</span><span class="n">K</span> <span class="o">-</span> <span class="n">K</span> <span class="o">@</span> <span class="n">Psi</span> <span class="o">@</span> <span class="n">Psi</span><span class="o">.</span><span class="n">T</span> <span class="o">@</span> <span class="n">M</span>
              <span class="o">-</span> <span class="n">M</span> <span class="o">@</span> <span class="n">Psi</span> <span class="o">@</span> <span class="n">Psi</span><span class="o">.</span><span class="n">T</span> <span class="o">@</span> <span class="n">K</span>
              <span class="o">+</span> <span class="n">M</span> <span class="nd">@Psi</span><span class="o">@</span> <span class="n">Psi</span><span class="o">.</span><span class="n">T</span> <span class="o">@</span> <span class="n">K</span> <span class="o">@</span> <span class="n">Psi</span> <span class="o">@</span> <span class="n">Psi</span><span class="o">.</span><span class="n">T</span> <span class="o">@</span> <span class="n">M</span>
              <span class="o">+</span> <span class="n">M</span> <span class="o">@</span> <span class="n">Psi</span> <span class="o">@</span> <span class="n">lam</span> <span class="o">@</span> <span class="n">Psi</span><span class="o">.</span><span class="n">T</span> <span class="o">@</span> <span class="n">M</span><span class="p">)</span>

    <span class="k">else</span><span class="p">:</span>  <span class="c1"># Defaults to Baruch method.</span>
        <span class="n">Phi</span> <span class="o">=</span> <span class="n">rsolve</span><span class="p">(</span><span class="n">la</span><span class="o">.</span><span class="n">sqrtm</span><span class="p">(</span><span class="n">Psi</span><span class="o">.</span><span class="n">T</span> <span class="o">@</span> <span class="n">M</span> <span class="o">@</span> <span class="n">Psi</span><span class="p">),</span> <span class="n">Psi</span><span class="p">,</span> <span class="n">assume_a</span><span class="o">=</span><span class="s1">&#39;pos&#39;</span><span class="p">)</span>

        <span class="n">PhiPhiT</span> <span class="o">=</span> <span class="n">Phi</span><span class="nd">@Phi</span><span class="o">.</span><span class="n">T</span>

        <span class="n">sec_term</span> <span class="o">=</span> <span class="n">K</span> <span class="o">@</span> <span class="n">PhiPhiT</span> <span class="o">@</span> <span class="n">M</span>

        <span class="n">Kc</span> <span class="o">=</span> <span class="n">K</span> <span class="o">-</span> <span class="n">sec_term</span> <span class="o">-</span> <span class="n">sec_term</span><span class="o">.</span><span class="n">T</span> \
            <span class="o">+</span> <span class="n">M</span> <span class="o">@</span> <span class="n">PhiPhiT</span> <span class="o">@</span> <span class="n">K</span> <span class="o">@</span> <span class="n">PhiPhiT</span> <span class="o">@</span> <span class="n">M</span>\
            <span class="o">+</span> <span class="n">M</span> <span class="o">@</span> <span class="n">Phi</span> <span class="o">@</span> <span class="n">lam</span> <span class="o">@</span> <span class="n">Phi</span><span class="o">.</span><span class="n">T</span> <span class="o">@</span> <span class="n">M</span>

        <span class="n">Mc</span> <span class="o">=</span> <span class="n">M</span>

    <span class="k">return</span> <span class="n">Mc</span><span class="p">,</span> <span class="n">Kc</span></div>


<span class="k">def</span> <span class="nf">slice</span><span class="p">(</span><span class="n">Matrix</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Slice a matrix properly- like Octave.</span>

<span class="sd">    Addresses the confounding inconsistency that `M[a,b]` acts differently if</span>
<span class="sd">    `a` and `b` are the same length or different lengths.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    Matrix : float array</span>
<span class="sd">        Arbitrary array</span>
<span class="sd">    a, b : int lists or arrays</span>
<span class="sd">        list of rows and columns to be selected from `Matrix`</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    Matrix : float array</span>
<span class="sd">        Properly sliced matrix- no casting allowed.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># a = a.reshape(-1)</span>
    <span class="c1"># b = b.reshape(-1)</span>

    <span class="k">return</span> <span class="p">(</span><span class="n">Matrix</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">a</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">b</span><span class="p">]</span>
            <span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">a</span><span class="p">)</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">b</span><span class="p">)</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span></div>


<div class="viewcode-block" id="rsolve"><a class="viewcode-back" href="../reference/system.html#system.rsolve">[docs]</a><span class="k">def</span> <span class="nf">rsolve</span><span class="p">(</span><span class="n">B</span><span class="p">,</span> <span class="n">C</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Solve right Gauss elimination equation.</span>

<span class="sd">    Given :math:`A B  = C` return :math:`A = C B^{-1}`</span>

<span class="sd">    This uses `scipy.linalg.solve` with a little matrix manipulation first.</span>
<span class="sd">    All keyword arguments of `scipy.linalg.solve` may be used.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    B, C : float arrays</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    A : float array</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; import numpy as np</span>
<span class="sd">    &gt;&gt;&gt; import vibrationtesting as vt</span>
<span class="sd">    &gt;&gt;&gt; B = np.array([[ 8, -4,  0],</span>
<span class="sd">    ...               [-4,  8, -4],</span>
<span class="sd">    ...               [ 0, -4,  4]])</span>
<span class="sd">    &gt;&gt;&gt; C = np.array([[ 32, -16,   0],</span>
<span class="sd">    ...            [-16,  36, -20],</span>
<span class="sd">    ...            [  4, -24,  20]])</span>
<span class="sd">    &gt;&gt;&gt; A = vt.rsolve(B, C)</span>
<span class="sd">    &gt;&gt;&gt; print(np.round(rsolve(B, C)))</span>
<span class="sd">    [[ 4.  0.  0.]</span>
<span class="sd">     [-0.  4. -1.]</span>
<span class="sd">     [ 0. -1.  4.]]</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    .. seealso:: `scipy.linalg.solve`</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">la</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">B</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">C</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span><span class="o">.</span><span class="n">T</span></div>


<div class="viewcode-block" id="real_modes"><a class="viewcode-back" href="../reference/system.html#system.real_modes">[docs]</a><span class="k">def</span> <span class="nf">real_modes</span><span class="p">(</span><span class="n">Psi</span><span class="p">,</span> <span class="n">autorotate</span> <span class="o">=</span> <span class="kc">True</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Real modes from complex modes.</span>

<span class="sd">    Assuming a transformation</span>

<span class="sd">    .. math:: Psi_{real} = Psi_{complex} T</span>

<span class="sd">    exists, where :math:`T` is a complex transformation matrix, find</span>
<span class="sd">    :math:`Psi_{real}` using linear algebra.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    Psi : complex float array</span>
<span class="sd">        Complex mode shapes (displacement)</span>
<span class="sd">    autorotate : Boolean, optional</span>
<span class="sd">        Attempt to rotate to near-real first</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    Psi : float array</span>
<span class="sd">        Real modes</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; import vibrationtesting as vt</span>
<span class="sd">    &gt;&gt;&gt; M = np.array([[4, 0, 0],</span>
<span class="sd">    ...               [0, 4, 0],</span>
<span class="sd">    ...               [0, 0, 4]])</span>
<span class="sd">    &gt;&gt;&gt; Cso = np.array([[.1,0,0],</span>
<span class="sd">    ...                 [0,0,0],</span>
<span class="sd">    ...                 [0,0,0]])</span>
<span class="sd">    &gt;&gt;&gt; K = np.array([[8, -4, 0],</span>
<span class="sd">    ...               [-4, 8, -4],</span>
<span class="sd">    ...               [0, -4, 4]])</span>
<span class="sd">    &gt;&gt;&gt; Bt = np.array([[1],[0],[0]])</span>
<span class="sd">    &gt;&gt;&gt; Ca = np.array([[1,0,0]])</span>
<span class="sd">    &gt;&gt;&gt; Cd = Cv = np.zeros_like(Ca)</span>
<span class="sd">    &gt;&gt;&gt; A, B, C, D = vt.so2ss(M, Cso, K, Bt, Cd, Cv, Ca)</span>
<span class="sd">    &gt;&gt;&gt; Am, Bm, Cm, Dm, eigenvalues, modes = vt.ss_modal(A, B, C, D)</span>
<span class="sd">    &gt;&gt;&gt; Psi = vt.real_modes(modes[:,0::2])</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    .. note:: Rotation of modes should be performed to get them as close to real</span>
<span class="sd">      as possible first.</span>
<span class="sd">    .. warning:: Current autorotate bases the rotation on de-rotating the first</span>
<span class="sd">      element of each vector. User can use their own pre-process by doing to</span>
<span class="sd">      and setting `autorotate` to False.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">autorotate</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
<div class="viewcode-block" id="ss_modal"><a class="viewcode-back" href="../reference/system.html#system.ss_modal">[docs]</a>        <span class="n">Psi</span> <span class="o">=</span> <span class="n">Psi</span><span class="nd">@np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">angle</span><span class="p">(</span><span class="n">Psi</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:])</span> <span class="o">*</span> <span class="o">-</span><span class="mi">1</span><span class="n">j</span><span class="p">))</span>
    <span class="n">Psi_real</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">Psi</span><span class="p">)</span>
    <span class="n">Psi_im</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">imag</span><span class="p">(</span><span class="n">Psi</span><span class="p">)</span>

    <span class="n">Psi</span> <span class="o">=</span> <span class="n">Psi_real</span> <span class="o">+</span> <span class="n">Psi_im</span> <span class="o">@</span> <span class="n">la</span><span class="o">.</span><span class="n">lstsq</span><span class="p">(</span><span class="n">Psi_real</span><span class="p">,</span> <span class="n">Psi_im</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">Psi</span></div>


<span class="k">def</span> <span class="nf">ss_modal</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">C</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">D</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;State space modes, frequencies, damping ratios, and modal matrices.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    A, B, C, D : float arrays</span>
<span class="sd">        State space system matrices</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    Am, Bm, Cm, Dm : float arrays</span>
<span class="sd">        Modal state space system matrices</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; import vibrationtesting as vt</span>
<span class="sd">    &gt;&gt;&gt; M = np.array([[4, 0, 0],</span>
<span class="sd">    ...               [0, 4, 0],</span>
<span class="sd">    ...               [0, 0, 4]])</span>
<span class="sd">    &gt;&gt;&gt; Cso = np.array([[.1,0,0],</span>
<span class="sd">    ...                 [0,0,0],</span>
<span class="sd">    ...                 [0,0,0]])</span>
<span class="sd">    &gt;&gt;&gt; K = np.array([[8, -4, 0],</span>
<span class="sd">    ...               [-4, 8, -4],</span>
<span class="sd">    ...               [0, -4, 4]])</span>
<span class="sd">    &gt;&gt;&gt; Bt = np.array([[1],[0],[0]])</span>
<span class="sd">    &gt;&gt;&gt; Ca = np.array([[1,0,0]])</span>
<span class="sd">    &gt;&gt;&gt; Cd = Cv = np.zeros_like(Ca)</span>
<span class="sd">    &gt;&gt;&gt; A, B, C, D = vt.so2ss(M, Cso, K, Bt, Cd, Cv, Ca)</span>
<span class="sd">    &gt;&gt;&gt; Am, Bm, Cm, Dm, eigenvalues, modes = vt.ss_modal(A, B, C, D)</span>
<span class="sd">    &gt;&gt;&gt; print(Am+(0.00001+0.00001j))</span>
<span class="sd">    [[-0.0013+0.4451j  0.0000+0.j      0.0000+0.j      0.0000+0.j      0.0000+0.j</span>
<span class="sd">       0.0000+0.j    ]</span>
<span class="sd">     [ 0.0000+0.j     -0.0013-0.445j   0.0000+0.j      0.0000+0.j      0.0000+0.j</span>
<span class="sd">       0.0000+0.j    ]</span>
<span class="sd">     [ 0.0000+0.j      0.0000+0.j     -0.0068+1.247j   0.0000+0.j      0.0000+0.j</span>
<span class="sd">       0.0000+0.j    ]</span>
<span class="sd">     [ 0.0000+0.j      0.0000+0.j      0.0000+0.j     -0.0068-1.247j</span>
<span class="sd">       0.0000+0.j      0.0000+0.j    ]</span>
<span class="sd">     [ 0.0000+0.j      0.0000+0.j      0.0000+0.j      0.0000+0.j</span>
<span class="sd">      -0.0044+1.8019j  0.0000+0.j    ]</span>
<span class="sd">     [ 0.0000+0.j      0.0000+0.j      0.0000+0.j      0.0000+0.j      0.0000+0.j</span>
<span class="sd">      -0.0044-1.8019j]]</span>
<span class="sd">    &gt;&gt;&gt; print(Cm)</span>
<span class="sd">    [[ 0.0594-0.0001j  0.0594+0.0001j  0.0039-0.717j   0.0039+0.717j</span>
<span class="sd">       0.0241-0.9307j  0.0241+0.9307j]]</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">B</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">B</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">C</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">C</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">D</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">D</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>

    <span class="n">eigenvalues</span><span class="p">,</span> <span class="n">vectors</span> <span class="o">=</span> <span class="n">la</span><span class="o">.</span><span class="n">eig</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>

    <span class="n">idxp</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">eigenvalues</span><span class="p">)</span><span class="o">.</span><span class="n">argsort</span><span class="p">()</span>
    <span class="n">eigenvalues</span> <span class="o">=</span> <span class="n">eigenvalues</span><span class="p">[</span><span class="n">idxp</span><span class="p">]</span>
    <span class="n">vectors</span> <span class="o">=</span> <span class="n">vectors</span><span class="p">[:,</span> <span class="n">idxp</span><span class="p">]</span>

    <span class="n">A_modal</span> <span class="o">=</span> <span class="n">la</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">vectors</span><span class="p">,</span><span class="n">A</span><span class="p">)</span><span class="nd">@vectors</span>
    <span class="n">B_modal</span> <span class="o">=</span> <span class="n">la</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">vectors</span><span class="p">,</span><span class="n">B</span><span class="p">)</span>
    <span class="n">C_modal</span> <span class="o">=</span> <span class="n">C</span><span class="nd">@vectors</span>
    <span class="c1"># D_modal = D wasted CPUs</span>
    <span class="k">return</span> <span class="n">A_modal</span><span class="p">,</span> <span class="n">B_modal</span><span class="p">,</span> <span class="n">C_modal</span><span class="p">,</span> <span class="n">D</span><span class="p">,</span> <span class="n">eigenvalues</span><span class="p">,</span> <span class="n">vectors</span></div>
</pre></div>

          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../index.html">Vibration Testing</a></h1>



<p class="blurb">Vibration Testing Analysis</p>






<h3>Navigation</h3>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../tutorial/index.html">Tutorial</a></li>
<li class="toctree-l1"><a class="reference internal" href="../reference/index.html">Reference</a></li>
</ul>


<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="../search.html" method="get">
      <div><input type="text" name="q" /></div>
      <div><input type="submit" value="Go" /></div>
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2017, Joseph C. Slater.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 1.6.6</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.10</a>
      
    </div>

    

    
    <script type="text/javascript">

      var _gaq = _gaq || [];
      _gaq.push(['_setAccount', 'UA-62100376-6']);
      _gaq.push(['_setDomainName', 'none']);
      _gaq.push(['_setAllowLinker', true]);
      _gaq.push(['_trackPageview']);

      (function() {
        var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
        ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
        var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
      })();

    </script>
    
  </body>
</html>